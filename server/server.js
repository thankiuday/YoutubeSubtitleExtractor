const express = require('express');
const cors = require('cors');
const { YoutubeTranscript } = require('youtube-transcript');

const app = express();

// Enable CORS for the React app
app.use(cors());

// Add error handling middleware
app.use((err, req, res, next) => {
  console.error('Server error:', err);
  res.status(500).json({ error: 'Internal server error: ' + err.message });
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

// Get list of available caption tracks
app.get('/api/subtitles/list', async (req, res) => {
  try {
    const { videoId } = req.query;
    if (!videoId) {
      return res.status(400).json({ error: 'Video ID is required' });
    }

    console.log('Fetching caption tracks for video:', videoId);

    // Try to get captions in different languages
    const languages = [
      { code: 'en', name: 'English', country: 'US' },
      { code: 'hi', name: 'Hindi', country: 'IN' },
      { code: 'es', name: 'Spanish', country: 'ES' },
      { code: 'fr', name: 'French', country: 'FR' },
      { code: 'de', name: 'German', country: 'DE' },
      { code: 'it', name: 'Italian', country: 'IT' },
      { code: 'pt', name: 'Portuguese', country: 'PT' },
      { code: 'ru', name: 'Russian', country: 'RU' },
      { code: 'ja', name: 'Japanese', country: 'JP' },
      { code: 'ko', name: 'Korean', country: 'KR' },
      { code: 'zh', name: 'Chinese', country: 'CN' }
    ];

    const availableTracks = [];

    for (const lang of languages) {
      try {
        console.log(`Trying to fetch ${lang.name} captions...`);
        const transcript = await YoutubeTranscript.fetchTranscript(videoId, {
          lang: lang.code,
          country: lang.country
        });

        if (transcript && transcript.length > 0) {
          console.log(`Found ${lang.name} captions:`, transcript.length, 'entries');
          availableTracks.push({
            id: lang.code,
            languageCode: lang.code,
            name: lang.name,
            kind: 'captions'
          });
        }
      } catch (error) {
        console.log(`Error fetching ${lang.name} captions:`, error.message);
        
        // Try auto-generated captions
        try {
          const transcript = await YoutubeTranscript.fetchTranscript(videoId, {
            lang: lang.code,
            country: lang.country,
            autoGenerated: true
          });

          if (transcript && transcript.length > 0) {
            console.log(`Found auto-generated ${lang.name} captions:`, transcript.length, 'entries');
            availableTracks.push({
              id: lang.code,
              languageCode: lang.code,
              name: `${lang.name} (Auto-generated)`,
              kind: 'captions'
            });
          }
        } catch (autoError) {
          console.log(`Error fetching auto-generated ${lang.name} captions:`, autoError.message);
        }
      }
    }

    if (availableTracks.length > 0) {
      console.log('Found available tracks:', availableTracks);
      return res.json(availableTracks);
    }

    console.log('No captions found for any language');
    return res.status(404).json({ error: 'No captions available for this video' });
  } catch (error) {
    console.error('Error fetching caption tracks:', error);
    res.status(500).json({ error: 'Failed to fetch caption tracks: ' + error.message });
  }
});

// Fetch subtitles for a specific track
app.get('/api/subtitles/fetch', async (req, res) => {
  try {
    const { videoId, trackId } = req.query;
    if (!videoId || !trackId) {
      return res.status(400).json({ error: 'Video ID and Track ID are required' });
    }

    console.log('Fetching subtitles for video:', videoId, 'track:', trackId);

    let transcript = null;
    let error = null;

    // Get the appropriate country code for the language
    const countryMap = {
      en: 'US',
      hi: 'IN',
      es: 'ES',
      fr: 'FR',
      de: 'DE',
      it: 'IT',
      pt: 'PT',
      ru: 'RU',
      ja: 'JP',
      ko: 'KR',
      zh: 'CN'
    };

    const country = countryMap[trackId] || 'US';

    // Try different options for fetching the transcript
    const options = [
      { lang: trackId, country: country },
      { lang: trackId },
      { lang: trackId, country: country, autoGenerated: true }
    ];

    for (const option of options) {
      try {
        console.log('Trying with options:', option);
        transcript = await YoutubeTranscript.fetchTranscript(videoId, option);
        
        if (transcript && transcript.length > 0) {
          console.log('Successfully fetched transcript with options:', option);
          console.log('Sample text:', transcript[0].text);
          break;
        }
      } catch (e) {
        console.log('Failed with options:', option, 'Error:', e.message);
        error = e;
      }
    }

    if (!transcript || transcript.length === 0) {
      throw new Error(error ? error.message : 'No subtitle content found');
    }

    // Format the transcript entries - just return the text without timestamps
    const formattedTranscript = transcript.map(entry => ({
      text: entry.text.trim()
    }));

    console.log('Successfully fetched subtitles:', formattedTranscript.length, 'entries');
    res.json({ subtitles: formattedTranscript });
  } catch (error) {
    console.error('Error fetching subtitles:', error);
    res.status(500).json({ error: 'Failed to fetch subtitles: ' + error.message });
  }
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Proxy server running on port ${PORT}`);
  console.log('Server is ready to handle requests');
});